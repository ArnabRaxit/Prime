/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.common.utils;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;

import com.handlerexploit.common.Configuration;
import com.handlerexploit.internal.android.DiskLruCache;
import com.handlerexploit.internal.android.DiskLruCache.Editor;
import com.handlerexploit.internal.android.DiskLruCache.Snapshot;
import com.handlerexploit.internal.android.LruCache;
import com.handlerexploit.internal.apache.DigestUtils;
import com.handlerexploit.internal.apache.IOUtils;

public class ImageManager {

    private static ImageManager sInstance = new ImageManager();
    
    private Handler mHandler = new Handler();
    
    private DiskLruCache mDiskLruCache;
    
    private ExecutorService mDiskExecutorService = Executors.newCachedThreadPool();

    private ExecutorService mNetworkExecutorService = newConfiguredThreadPool();

    private LruCache<String, Bitmap> mLruCache = new LruCache<String, Bitmap>(Configuration.getMemoryCacheSizeInBytes()) {
        
        @Override
        public int sizeOf(String key, Bitmap value) {
            return value.getRowBytes() * value.getHeight();
        }
    };

    private ImageManager() {
        super();
    }
    
    public static ImageManager getInstance() {
        return sInstance;
    }
    
    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link String} through the {@link OnImageRecievedListener} synchronously
     * or asynchronously depending on the state of the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     */
    public void get(final Context context, final String source, final OnImageRecievedListener onImageRecievedListener) {
        if (!preExecutionChecks(context, source, onImageRecievedListener)) return;

        /*
         * Attempt the retrieve the Bitmap from the LruCache
         */
        Bitmap bitmap = getBitmapFromCache(source);
        if (bitmap != null) {
            /*
             * Exit through the OnImageRecievedListener on the UI Thread
             */
            onImageRecievedListener.onImageReceived(source, bitmap);
            return;
        }
        
        mDiskExecutorService.execute(new Runnable() {
            public void run() {
                /*
                 * Attempt the retrieve the Bitmap from the disk
                 */
                final Bitmap bitmap = getBitmapFromDisk(source);
                if (bitmap != null) {
                    /*
                     * Exit through the OnImageRecievedListener on the UI Thread
                     */
                    mHandler.post(new Runnable() {

                        @Override
                        public void run() {
                            onImageRecievedListener.onImageReceived(source, bitmap);
                        }
                    });
                } else {
                    mNetworkExecutorService.execute(new Runnable() {
                        
                        @Override
                        public void run() {
                            /*
                             * Attempt the retrieve the Bitmap from the network
                             */
                            final Bitmap bitmap = getBitmapFromNetwork(source);
                            if (bitmap != null) {
                                /*
                                 * Exit through the OnImageRecievedListener on the UI Thread
                                 */
                                mHandler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        onImageRecievedListener.onImageReceived(source, bitmap);
                                    }
                                });
                            }
                        }
                    });
                }
            }
        });
    }
    
    private Bitmap getBitmapFromCache(String source) {
        /*
         * Attempt the retrieve the byte array from the LruCache
         */
        return mLruCache.get(getKey(source));
    }
    
    private Bitmap getBitmapFromDisk(String source) {
        String key = getKey(source);
        Bitmap bitmap = null;
        
        /*
         * Attempt the retrieve the byte array from the DiskLruCache
         */
        Snapshot snapshot = null;
        try {
            snapshot = mDiskLruCache.get(key);
        } catch (IOException e) {
            // Ignore
        }
        if (snapshot != null) {
            
            /*
             * Decode the stored byte array into a Bitmap
             */
            Options options = new Options();
            options.inPurgeable = true;
            options.inInputShareable = true;
            InputStream inputStream = null;
            try {
                inputStream = snapshot.getInputStream(0);
                bitmap = BitmapFactory.decodeStream(inputStream, null, options);
            } catch (Throwable t) {
                // Ignore
            } finally {
                IOUtils.closeQuietly(inputStream);
            }
            
            /*
             * Store the Bitmap in the LruCache
             */
            if (bitmap != null) {
                mLruCache.put(key, bitmap);
            }
        }
        return bitmap;
    }
    
    private Bitmap getBitmapFromNetwork(String source) {
        String key = getKey(source);
        Bitmap bitmap = null;
        
        byte[] byteArray = copyURLToByteArray(source);
        if (byteArray == null) {
            return null;
        }
        
        /*
         * Store the byte array in the DiskLruCache
         */
        Editor editor = null;
        ByteArrayInputStream byteArrayInputStream = null;
        OutputStream outputStream = null;
        try {
            while (editor == null) {
                editor = mDiskLruCache.edit(key);
            }
            
            byteArrayInputStream = new ByteArrayInputStream(byteArray);
            outputStream = editor.newOutputStream(0);
            
            IOUtils.copy(byteArrayInputStream, outputStream);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(byteArrayInputStream);
            IOUtils.closeQuietly(outputStream);
            
            if (editor != null) {
                try {
                    editor.commit();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        
        /*
         * Decode the byte array into a Bitmap
         */
        Options options = new Options();
        options.inPurgeable = true;
        options.inInputShareable = true;
        try {
            bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.length);
        } catch (Throwable t) {
            // Ignore
        }
        
        /*
         * Store the Bitmap in the LruCache
         */
        if (bitmap != null) {
            mLruCache.put(key, bitmap);
        }
        
        return bitmap;
    }
    
    private byte[] copyURLToByteArray(String source) {
        byte[] byteArray = null;
        InputStream inputStream = null;
        ByteArrayOutputStream byteArrayOutputStream = null;
        try {
            inputStream = new URL(source).openConnection().getInputStream();
            byteArrayOutputStream = new ByteArrayOutputStream();
            
            IOUtils.copy(inputStream, byteArrayOutputStream);
            
            byteArray = byteArrayOutputStream.toByteArray();
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(inputStream);
            IOUtils.closeQuietly(byteArrayOutputStream);
        }
        return byteArray;
    }
    
    private String getKey(String source) {
        return DigestUtils.sha256Hex(source);
    }
    
    private boolean preExecutionChecks(Context context, String source, OnImageRecievedListener onImageRecievedListener) {
        if (source == null || onImageRecievedListener == null) return false;

        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
            throw new CalledFromWrongThreadException("This must only be executed on the main UI Thread!");
        }
        
        if (mDiskLruCache == null) {
            File directory = new File(Environment.getDataDirectory().getAbsolutePath() + "/data/" + context.getPackageName() + "/cache/images/");
            try {
                mDiskLruCache = DiskLruCache.open(directory, 1, 1, Integer.MAX_VALUE);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        
        return true;
    }
    
    private static ExecutorService newConfiguredThreadPool() {
        return new ThreadPoolExecutor(0, Configuration.getAsynchronousNetworkThreadCount(), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
    }
    
    @SuppressWarnings("serial")
    private static final class CalledFromWrongThreadException extends RuntimeException {
        public CalledFromWrongThreadException(String msg) {
            super(msg);
        }
    }
    
    public static interface OnImageRecievedListener {
        public void onImageReceived(String source, Bitmap bitmap);
    }
}