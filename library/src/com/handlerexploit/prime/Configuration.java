/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.prime;

import java.io.IOException;
import java.io.InputStream;
import java.util.Properties;

public class Configuration {

    private static boolean sDebugging = false;
    private static int sMemoryCacheSizeInKilobytes = 4096;
    private static int sDiskCacheSizeInKilobytes = 8192;
    private static int sAsynchronousNetworkThreadCount = Integer.MAX_VALUE;
    private static Location sImageDownloadLocation = Location.INTERNAL;
    
    static {
        Properties properties = new Properties();
        try {
            InputStream configInputStream = Configuration.class.getClassLoader().getResourceAsStream("assets/prime.properties");
            if (configInputStream != null) {
                properties.load(configInputStream);
                
                sDebugging = toBoolean(properties.get("debug"));
                
                int memoryCacheSizeInKilobytes = toInteger(properties.get("cache.memSize"));
                if (memoryCacheSizeInKilobytes > -1) {
                    sMemoryCacheSizeInKilobytes = memoryCacheSizeInKilobytes;
                }
                
                int diskCacheSizeInKilobytes = toInteger(properties.get("cache.diskSize"));
                if (diskCacheSizeInKilobytes > -1) {
                    sDiskCacheSizeInKilobytes = diskCacheSizeInKilobytes;
                }
                
                try {
                    sImageDownloadLocation = Location.valueOf((properties.getProperty("cache.diskLocation") + "").toUpperCase());
                } catch (IllegalArgumentException ignore) {
                    // Silently ignore
                }
                
                int asynchronousNetworkThreadCount = toInteger(properties.get("async.numThreads"));
                if (asynchronousNetworkThreadCount > -1) {
                    sAsynchronousNetworkThreadCount = asynchronousNetworkThreadCount;
                }
            }
        } catch (IOException ignore) {
            // Silently ignore
        }
    }
    
    private static boolean toBoolean(Object object) {
        if (object != null) {
            try {
                return Boolean.valueOf(object.toString());
            } catch (Exception ignore) {
                // Silently ignore
            }
        }
        return false;
    }
    
    private static int toInteger(Object object) {
        if (object != null) {
            try {
                return Integer.parseInt(object.toString());
            } catch (Exception ignore) {
                // Silently ignore
            }
        }
        return -1;
    }
    
    public enum Location {
        INTERNAL,
        EXTERNAL
    }
    
    public static boolean isDebugging() {
        return sDebugging;
    }
    
    public static Location getImageDownloadLocation() {
        return sImageDownloadLocation;
    }
    
    public static int getMemoryCacheSizeInBytes() {
        if (sMemoryCacheSizeInKilobytes < Integer.MAX_VALUE) {
            return (sMemoryCacheSizeInKilobytes * 1024) + 1024;
        } else {
            return sMemoryCacheSizeInKilobytes;
        }
    }
    
    public static int getDiskCacheSizeInBytes() {
        if (sDiskCacheSizeInKilobytes < Integer.MAX_VALUE) {
            return (sDiskCacheSizeInKilobytes * 1024) + 1024;
        } else {
            return sDiskCacheSizeInKilobytes;
        }
    }
    
    public static int getAsynchronousNetworkThreadCount() {
        return sAsynchronousNetworkThreadCount;
    }
}