/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.prime.utils;

import static com.handlerexploit.prime.utils.ImageManagerUtils.copyBitmapToDiskLruCache;
import static com.handlerexploit.prime.utils.ImageManagerUtils.copyURLToByteArray;
import static com.handlerexploit.prime.utils.ImageManagerUtils.decodeByteArray;
import static com.handlerexploit.prime.utils.ImageManagerUtils.decodeFromSnapshot;
import static com.handlerexploit.prime.utils.ImageManagerUtils.getImagesDirectory;
import static com.handlerexploit.prime.utils.ImageManagerUtils.getKey;
import static com.handlerexploit.prime.utils.ImageManagerUtils.newConfiguredLruCache;
import static com.handlerexploit.prime.utils.ImageManagerUtils.newConfiguredThreadPool;
import static com.handlerexploit.prime.utils.ImageManagerUtils.printStackTrace;
import static com.handlerexploit.prime.utils.ImageManagerUtils.verifySourceOverTime;

import java.io.IOException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import android.content.Context;
import android.graphics.Bitmap;
import android.os.Handler;
import android.os.Looper;

import com.handlerexploit.common.utils.DiskLruCache;
import com.handlerexploit.common.utils.DiskLruCache.Snapshot;
import com.handlerexploit.common.utils.LruCache;
import com.handlerexploit.prime.Configuration;
import com.handlerexploit.prime.widgets.RemoteImageView;

/**
 * This class is responsible for retrieving and caching all {@link Bitmap}
 * images. Using a two tier caching mechanism the images are saved both in
 * memory and on disk for both an efficient and clean user experience.
 * Internally we use {@link LruCache} and {@link DiskLruCache} for all of our
 * caching. </br></br>
 * 
 * The most fool-proof method of using this class is to use
 * {@link RemoteImageView#setImageURL(String)}.
 * 
 * <pre>
 * String imageURL = &quot;http://example.com/image&quot;;
 * RemoteImageView remoteImageView = (RemoteImageView) findViewById(R.id.icon);
 * remoteImageView.setImageURL(imageURL);
 * </pre>
 * 
 * If you want to receive images asynchronously without the use of the
 * {@link RemoteImageView} wrapper you can easily get images by using
 * {@link ImageManager#get(String, OnImageReceivedListener)} or
 * {@link ImageManager#get(Request)}.
 * 
 * <pre>
 * final String imageURL = &quot;http://example.com/image&quot;;
 * ImageManager imageManager = ImageManager.getInstance(context);
 * imageManager.get(imageURL, new OnImageReceivedListener() {
 * 
 *     public void onImageReceived(String source, Bitmap bitmap) {
 *         // Do something with the retrieved Bitmap
 *     }
 * }
 * 
 * imageManager.get(new Request() {
 * 
 *     public String getSource() {
 *         return imageURL;
 *     }
 * 
 *     public void onImageReceived(String source, Bitmap bitmap) {
 *         // Do something with the retrieved Bitmap
 *     }
 * });
 * </pre>
 * 
 * If you want to retrieve images synchronously you can use
 * {@link ImageManager#get(String)}.
 * 
 * <pre>
 * ImageManager imageManager = ImageManager.getInstance(context);
 * String imageURL = &quot;http://example.com/image&quot;;
 * Bitmap bitmap = imageManager.get(imageURL);
 * </pre>
 */
public final class ImageManager {

    private static ImageManager sInstance;

    private Handler mHandler = new Handler();

    private DiskLruCache mDiskLruCache;

    private LruCache<String, Bitmap> mLruCache = newConfiguredLruCache();

    private ExecutorService mNetworkExecutorService = newConfiguredThreadPool();

    private ExecutorService mDiskExecutorService = Executors.newCachedThreadPool();

    private ImageManager(Context context) {
        try {
            mDiskLruCache = DiskLruCache.open(getImagesDirectory(context), 1, 1, Configuration.DISK_CACHE_SIZE_KB * 1024);
        } catch (IOException e) {
            printStackTrace(e);
            throw new RuntimeException(e);
        }
    }

    public static synchronized ImageManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new ImageManager(context);
        }
        return sInstance;
    }

    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link String}. This is a synchronous call, if you need to asynchronously
     * retrieve an image use
     * {@link ImageManager#get(String, OnImageReceivedListener)} or
     * {@link ImageManager#get(Request)}.
     * 
     * @param source
     *            The URL of a remote image
     */
    public Bitmap get(final String source) {
        String key = getKey(source);

        Bitmap bitmap = getBitmapFromMemory(key);

        if (bitmap == null) {
            bitmap = getBitmapFromDisk(key);
        }

        if (bitmap == null) {
            bitmap = getBitmapFromNetwork(key, source, 0, 0, null);
        }

        return bitmap;
    }

    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link OnImageReceivedListener} synchronously or asynchronously depending
     * on the state of the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     * 
     * @param source
     *            The URL of a remote image
     * @param listener
     *            Listener for being notified when image is retrieved, can be
     *            null
     */
    public void get(final String source, final OnImageReceivedListener listener) {
        get(new Request() {

            @Override
            public String getSource() {
                return source;
            }

            @Override
            public void onImageReceived(String source, Bitmap bitmap) {
                if (listener != null) {
                    listener.onImageReceived(source, bitmap);
                }
            }
        });
    }

    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link Request} synchronously or asynchronously depending on the state of
     * the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     */
    public void get(final Request request) {
        if (request instanceof ExtendedRequest) {
            get((ExtendedRequest) request);
        } else {
            get(new SimpleRequest(request));
        }
    }

    private void get(final ExtendedRequest request) {
        final String source = request != null ? request.getSource() : null;
        if (source == null) {
            return;
        }

        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
            throw new RuntimeException("This must only be executed on the main UI Thread!");
        }

        final int requestHeight = request.getHeight();
        final int requestWidth = request.getWidth();

        final String key = requestHeight > 0 && requestWidth > 0 ? getKey(source + requestHeight + "x" + requestWidth) : getKey(source);

        Bitmap bitmap = getBitmapFromMemory(key);
        if (bitmap != null) {
            request.onImageReceived(source, bitmap);
        } else {
            mDiskExecutorService.execute(new Runnable() {

                @Override
                public void run() {
                    if (verifySourceOverTime(source, request)) {
                        final Bitmap bitmap = getBitmapFromDisk(key);
                        if (bitmap != null) {
                            mHandler.post(new Runnable() {

                                @Override
                                public void run() {
                                    request.onImageReceived(source, bitmap);
                                }
                            });
                        } else {
                            mNetworkExecutorService.execute(new Runnable() {

                                @Override
                                public void run() {
                                    final Bitmap bitmap = getBitmapFromNetwork(key, source, requestHeight, requestWidth, request);
                                    mHandler.post(new Runnable() {

                                        @Override
                                        public void run() {
                                            request.onImageReceived(source, bitmap);
                                        }
                                    });
                                }
                            });
                        }
                    }
                }
            });
        }
    }

    private Bitmap getBitmapFromMemory(String key) {
        return mLruCache.get(key);
    }

    private Bitmap getBitmapFromDisk(String key) {
        Bitmap bitmap = null;
        Snapshot snapshot = null;
        try {
            snapshot = mDiskLruCache.get(key);
        } catch (IOException e) {
            printStackTrace(e);
        } finally {
            if (snapshot != null) {
                bitmap = decodeFromSnapshot(snapshot);
                if (bitmap != null) {
                    mLruCache.put(key, bitmap);
                }
            }
        }
        return bitmap;
    }

    private Bitmap getBitmapFromNetwork(String key, String source, int height, int width, ExtendedRequest request) {
        byte[] byteArray = copyURLToByteArray(source);
        if (byteArray != null) {
            Bitmap bitmap = decodeByteArray(byteArray, height, width, request);
            if (bitmap != null) {
                copyBitmapToDiskLruCache(key, bitmap, mDiskLruCache);
                mLruCache.put(key, bitmap);
                return bitmap;
            }
        }
        return null;
    }

    /**
     * Listener for being notified when image is retrieved.
     */
    public static interface OnImageReceivedListener {

        /**
         * Notification that an image was retrieved, this is guaranteed to be
         * called on the UI thread.
         */
        public void onImageReceived(String source, Bitmap bitmap);
    }

    /**
     * Interface used to retrieve images remotely, used primarily with
     * {@link RemoteImageView} for optimization purposes.
     */
    public static interface Request extends OnImageReceivedListener {

        /**
         * Returns remote image URL, can be null.
         */
        public String getSource();
    }

    /**
     * Advanced interface for retrieving images in a non-standard way, this is
     * still under heavy development and will most likely change in the future.
     */
    public static interface ExtendedRequest extends Request {

        /**
         * Used in the processing of images after they are retrieved from the
         * remote source but before they are cached.
         */
        public Bitmap onPreProcess(Bitmap raw);

        /**
         * Used in the resizing of images intelligently.
         */
        public int getHeight();

        /**
         * Used in the resizing of images intelligently.
         */
        public int getWidth();
    }

    private static class SimpleRequest implements ExtendedRequest {

        private Request mRequest;

        public SimpleRequest(Request request) {
            mRequest = request;
        }

        @Override
        public void onImageReceived(String source, Bitmap bitmap) {
            mRequest.onImageReceived(source, bitmap);
        }

        @Override
        public String getSource() {
            return mRequest.getSource();
        }

        @Override
        public Bitmap onPreProcess(Bitmap raw) {
            return raw;
        }

        @Override
        public int getHeight() {
            return 0;
        }

        @Override
        public int getWidth() {
            return 0;
        }
    }
}