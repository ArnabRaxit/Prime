/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.prime.utils;

import static com.handlerexploit.prime.utils.ApacheUtils.IOUtils.closeQuietly;
import static com.handlerexploit.prime.utils.ApacheUtils.IOUtils.copy;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.BitmapFactory;
import android.graphics.BitmapFactory.Options;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;

import com.handlerexploit.prime.Configuration;
import com.handlerexploit.prime.utils.ApacheUtils.DigestUtils;
import com.handlerexploit.prime.utils.DiskLruCache.Editor;
import com.handlerexploit.prime.utils.DiskLruCache.Snapshot;

/**
 * This class is responsible for downloading and caching all {@link Bitmap}
 * images. We use a two tier caching mechanism to cache the images both on disk
 * and in memory. Using the {@link Configuration} class you can configure the
 * max byte size for both of these caches.
 */
public class ImageManager {
    
    private static final boolean DEBUGGING = Configuration.isDebugging();
    
    private static ImageManager sInstance;
    
    private Handler mHandler = new Handler();
    
    private DiskLruCache mDiskLruCache;
    
    private LruCache<String, Bitmap> mLruCache = newConfiguredLruCache();
    
    private ExecutorService mNetworkExecutorService = newConfiguredThreadPool();
    
    private ExecutorService mDiskExecutorService = Executors.newCachedThreadPool();

    private ImageManager(Context context) {
        File directory = new File(Environment.getDataDirectory().getAbsolutePath() + "/data/" + context.getPackageName() + "/cache/images/");
        try {
            mDiskLruCache = DiskLruCache.open(directory, 1, 1, Configuration.getDiskCacheSizeInBytes());
        } catch (IOException e) {
            printStackTrace(e);
            throw new RuntimeException(e);
        }
    }
    
    public static synchronized ImageManager getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new ImageManager(context);
        }
        return sInstance;
    }
    
    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link String}. This is a synchronous call, if you need to
     * asynchronously retrieve an image use {@link ImageManager#get(Request)}.
     */
    public Bitmap get(final String source) {
        Bitmap bitmap = getBitmapFromCache(source);
        
        if (bitmap == null) {
            bitmap = getBitmapFromDisk(source);
        }
        
        if (bitmap == null) {
            bitmap = getBitmapFromNetwork(source, null);
        }
        
        return bitmap;
    }
    
    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link Request} synchronously or asynchronously depending on the state of
     * the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     */
    public void get(final Request request) {
        get(new ExtendedRequest() {

            @Override
            public void onImageReceived(String source, Bitmap bitmap) {
                request.onImageReceived(source, bitmap);
            }

            @Override
            public String getSource() {
                return request.getSource();
            }

            @Override
            public Bitmap onPreProcess(Bitmap raw) {
                return raw;
            }
        });
    }
    
    public void get(final ExtendedRequest request) {
        final String source;
        if (request != null) {
            source = request.getSource();
            if (source == null) {
                request.onImageReceived(null, null);
                return;
            }
        } else {
            throw new RuntimeException("Request cannot be null!");
        }

        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
            throw new RuntimeException("This must only be executed on the main UI Thread!");
        }

        Bitmap bitmap = getBitmapFromCache(source);
        if (bitmap != null) {
            request.onImageReceived(source, bitmap);
        }
        
        mDiskExecutorService.execute(new Runnable() {
            
            @Override
            public void run() {
                if (!verifySourceOverTime(source, request)) {
                    mHandler.post(new Runnable() {
                        
                        @Override
                        public void run() {
                            request.onImageReceived(source, null);
                        }
                    });
                    return;
                }
                
                final Bitmap bitmap = getBitmapFromDisk(source);
                if (bitmap != null) {
                    mHandler.post(new Runnable() {
                        
                        @Override
                        public void run() {
                            request.onImageReceived(source, bitmap);
                        }
                    });
                } else {
                    mNetworkExecutorService.execute(new Runnable() {
                        
                        @Override
                        public void run() {
                            final Bitmap bitmap = getBitmapFromNetwork(source, request);
                            mHandler.post(new Runnable() {
                                
                                @Override
                                public void run() {
                                    request.onImageReceived(source, bitmap);
                                }
                            });
                        }
                    });
                }
            }
        });
    }
    
    private Bitmap getBitmapFromCache(String source) {
        return mLruCache.get(getKey(source));
    }
    
    private Bitmap getBitmapFromDisk(String source) {
        String key = getKey(source);
        
        Bitmap bitmap = null;
        Snapshot snapshot = null;
        try {
            snapshot = mDiskLruCache.get(key);
        } catch (IOException e) {
            printStackTrace(e);
        } finally {
            if (snapshot != null) {
                bitmap = decodeFromSnapshot(snapshot);
                if (bitmap != null) {
                    mLruCache.put(key, bitmap);
                }
            }
        }
        
        return bitmap;
    }

    private Bitmap getBitmapFromNetwork(String source, OnProcessListener listener) {
        String key = getKey(source);
        byte[] byteArray = copyURLToByteArray(source);
        if (byteArray != null) {
            Bitmap bitmap = decodeByteArray(byteArray, listener);
            if (bitmap != null) {
                copyBitmapToDiskLruCache(key, bitmap, mDiskLruCache);
                mLruCache.put(key, bitmap);
                return bitmap;
            }
        }
        return null;
    }
    
    protected static Bitmap decodeByteArray(byte[] byteArray, OnProcessListener listener) {
        try {
            Bitmap bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.length, getBitmapFactoryOptions());
            if (listener != null) {
                bitmap = listener.onPreProcess(bitmap);
            }
            return bitmap;
        } catch (Throwable t) {
            printStackTrace(t);
        }
        return null;
    }
    
    protected static byte[] copyURLToByteArray(String source) {
        InputStream inputStream = null;
        ByteArrayOutputStream byteArrayOutputStream = null;
        try {
            inputStream = new URL(source).openConnection().getInputStream();
            byteArrayOutputStream = new ByteArrayOutputStream();

            copy(inputStream, byteArrayOutputStream);
            return byteArrayOutputStream.toByteArray();
        } catch (MalformedURLException e) {
            printStackTrace(e);
        } catch (IOException e) {
            printStackTrace(e);
        } finally {
            closeQuietly(inputStream);
            closeQuietly(byteArrayOutputStream);
        }
        return null;
    }
    
    private static void copyBitmapToDiskLruCache(String key, Bitmap bitmap, DiskLruCache diskLruCache) {
        Editor editor = null;
        try {
            /*
             * We block here because Editor.edit will return null if another
             * edit is in progress
             */
            while (editor == null) {
                editor = diskLruCache.edit(key);
            }
            
            bitmap.compress(CompressFormat.PNG, 0, editor.newOutputStream(0));
        } catch (IOException e) {
            printStackTrace(e);
        } finally {
            if (editor != null) {
                try {
                    editor.commit();
                } catch (IOException e) {
                    printStackTrace(e);
                }
            }
        }
    }
    
    private static Bitmap decodeFromSnapshot(Snapshot snapshot) {
        InputStream inputStream = null;
        try {
            inputStream = snapshot.getInputStream(0);
            return BitmapFactory.decodeStream(inputStream, null, getBitmapFactoryOptions());
        } catch (Throwable t) {
            printStackTrace(t);
        } finally {
            closeQuietly(inputStream);
        }
        return null;
    }
    
    private static boolean verifySourceOverTime(String source, Request request) {
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            printStackTrace(e);
        } finally {
            if (source.equals(request.getSource())) {
                return true;
            }
        }
        return false;
    }
    
    private static String getKey(String source) {
        return DigestUtils.sha256Hex(source);
    }
    
    private static Options getBitmapFactoryOptions() {
        Options options = new Options();
        options.inPurgeable = true;
        options.inInputShareable = true;
        return options;
    }
    
    private static void printStackTrace(Throwable t) {
        if (DEBUGGING) {
            t.printStackTrace();
        }
    }
    
    private static ExecutorService newConfiguredThreadPool() {
        return new ThreadPoolExecutor(0, Configuration.getAsynchronousNetworkThreadCount(), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
    }
    
    private static LruCache<String, Bitmap> newConfiguredLruCache() {
        return new LruCache<String, Bitmap>(Configuration.getMemoryCacheSizeInBytes()) {
            
            @Override
            public int sizeOf(String key, Bitmap value) {
                return value.getRowBytes() * value.getHeight();
            }
        };
    }
    
    public static interface Request {
        
        public void onImageReceived(String source, Bitmap bitmap);
        
        public String getSource();
    }
    
    protected static interface OnProcessListener {

        public Bitmap onPreProcess(Bitmap raw);
    }
    
    public static interface ExtendedRequest extends Request, OnProcessListener {}
}